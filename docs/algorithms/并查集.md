### 并查集

> 并查集是一种用于管理元素所属集合的数据结构，实现为一个森林，其中每棵树表示一个集合，树中的节点表示对应集合中的元素。

##### 路径压缩优化

```python
# 并查集用于快速判断一个图中的两个点是否联通
#路经压缩优化
#题解（https://www.luogu.com.cn/problem/solution/P3367）
import sys
def find(fa, x):
    if fa[x] == x:
        return x
    fa[x] = find(fa, fa[x])
    return fa[x]
def solve():
    # 读取 n (元素数量) 和 m (操作次数)
    data = sys.stdin.readline().split()
    n, m = map(int, data)
    # 初始化并查集
    fa = [i for i in range(n + 1)]
    for _ in range(m):
        op, x, y = map(int, sys.stdin.readline().split())
        if op == 1: # 操作 1：合并集合 (Union)
            root_x = find(fa, x)
            root_y = find(fa, y)
            if root_x != root_y:
                fa[root_x] = root_y
        elif op == 2: # 操作 2：查询是否连通 (Check Connection)
            root_x = find(fa, x)
            root_y = find(fa, y)
            if root_x == root_y:
                print("Y")
            else:
                print("N")
if __name__ == '__main__':
    solve()
```

##### 按秩合并优化

```python
import sys
def find(fa, x):
    if fa[x] == x:
        return x
    fa[x] = find(fa, fa[x])
    return fa[x]
def solve():
    data = sys.stdin.readline().split()
    n, m = map(int, data)
    #初始化fa数组
    fa = [i for i in range(n + 1)]
    #siz用于记录该节点为根结点的树的高度
    siz = [1] * (n + 1)
    #以下是按高度合并的方式进行优化
    for _ in range(m):
        op, x, y = map(int, sys.stdin.readline().split())
        if op == 1:
            root_x = find(fa, x)
            root_y = find(fa, y)
            if root_x == root_y:
                continue
            if siz[root_y] < siz[root_x]:
                root_x, root_y = root_y, root_x
            fa[root_x] = root_y
            if siz[root_y] == siz[root_x]:
                siz[root_y] += 1
        elif op == 2:
            root_x = find(fa, x)
            root_y = find(fa, y)
            if root_x == root_y:
                print("Y")
            else:
                print("N")
if __name__ == '__main__':
    solve()
```

