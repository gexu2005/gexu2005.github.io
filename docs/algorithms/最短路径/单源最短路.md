### Bellman-Ford

> Bellman–Ford 算法所做的，就是不断尝试对图上每一条边进行松弛。我们每进行一轮循环，就对图上所有的边都尝试进行一次松弛操作，当一次循环中没有成功的松弛操作时，算法停止。

> 如果第 𝑛![n](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7) 轮循环时仍然存在能松弛的边，说明从 𝑆![S](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7) 点出发，能够抵达一个负环。(常用于判断一个图中是否存在负环)

> 需要注意的是，以 𝑆![S](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7) 点为源点跑 Bellman–Ford 算法时，如果没有给出存在负环的结果，只能说明从 𝑆![S](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7) 点出发不能抵达一个负环，而不能说明图上不存在负环。
>
> 因此如果需要判断整个图上是否存在负环，最严谨的做法是建立一个超级源点，向图上每个节点连一条权值为 0 的边，然后以超级源点为起点执行 Bellman–Ford 算法。

```python
#用于暴力求解单源最短路径
#同时可以判断一张图上是否存在负环，当最后一轮松弛时，仍有节点的最短路被更新，说明存在负环
#该算法可以求出有负权的图的最短路
#时间复杂度O（nm）
import sys
class Edge:
    def __init__(self,u = 0,v = 0,e = 0):
        self.v = v
        self.u = u
        self.e = e
INF = 0x3F3F3F3F
edge = []
def solve():
    n ,m, s = map(int ,input().split())
    for _ in range(m):
        u ,v ,e = map(int ,input().split())
        edge.append(Edge(u,v,e))
    dis = [INF] * (n + 1)
    dis[s] = 0
    def bellman_ford(n,s):
        flag = False
        for i in range(n):
            flag = False
            for i in edge:
                u ,v ,e = i.u , i.v , i.e
                if dis[u] == INF:continue
                if dis[v] > dis[u] + e:
                    dis[v] = dis[u] + e
                    flag = True
            if not flag:#表示当前没有新的节点的最短路径被更新
                break
        return flag
    if not bellman_ford(n, s):  # 说明不存在负环
        for i in range(1, n + 1):
            print(dis[i], end=' ')
if __name__ == '__main__':
    solve()
```

> SPFA :对于bellman_ford算法进行优化，每一次松弛只对上一次松弛中被更新的节点为出发点的边进行松弛，减少不必要的松弛

```python
from collections import deque
class Edge:
    def __init__(self, v=0, w=0):
        self.v = v
        self.w = w
e = [[Edge() for i in range(MAXN)] for j in range(MAXN)]
INF = 0x3F3F3F3F
def spfa(n, s):
    dis = [INF] * (n + 1)
    cnt = [0] * (n + 1)
    vis = [False] * (n + 1)
    q = deque()

    dis[s] = 0
    vis[s] = True
    q.append(s)
    while q:
        u = q.popleft()
        vis[u] = False
        for ed in e[u]:
            v, w = ed.v, ed.w
            if dis[v] > dis[u] + w:
                dis[v] = dis[u] + w
                cnt[v] = cnt[u] + 1  # 记录最短路经过的边数
                if cnt[v] >= n:
                    return False
                # 在不经过负环的情况下，最短路至多经过 n - 1 条边
                # 因此如果经过了多于 n 条边，一定说明经过了负环
                if not vis[v]:
                    q.append(v)
                    vis[v] = True

```

### Dijkstra

> 1. 将结点分成两个集合：已确定最短路长度的点集（记为 𝑆![S](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7) 集合）的和未确定最短路长度的点集（记为 𝑇![T](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7) 集合）。一开始所有的点都属于 𝑇![T](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7) 集合。
> 2. 初始化 𝑑𝑖𝑠(𝑠) =0![dis(s)=0](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7)，其他点的 𝑑𝑖𝑠![dis](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7) 均为 +∞![+\infty](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7)。
> 3. 重复以下操作
>    1. 从 𝑇![T](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7) 集合中，选取一个最短路长度最小的结点，移到 𝑆![S](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7) 集合中。
>    2. 对那些刚刚被加入 𝑆![S](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7) 集合的结点的所有出边执行松弛操作。

##### 朴素实现 适用于稠密图

```python
import sys
class Edge:
    def __init__(self, v = 0,w = 0):
        self.v = v
        self.w = w
def dijkstra(n ,e, s):
    INF = 0x3F3F3F3F
    dist = [INF] * (n + 1)
    st = [False] * (n + 1)
    dist[s] = 0
    for i in range(1,n + 1):
        u = 0
        mind = INF
        for j in range(1 , n + 1):
            if not st[j] and dist[j] < mind:
                u = j
                mind = dist[j]
        st[u] = True
        for ed in e[u]:
            v , w = ed.v , ed.w
            if dist[v] > dist[u] + w:
                dist[v] = dist[u] + w
    return dist
def solve():
    n , m , s = map(int ,input().split())
    e = [[] for _ in range(n + 1)]
    for _ in range(m):
        u , v , w = map(int ,input().split())
        e[u].append(Edge(v,w))
    dist = dijkstra(n,e,s)
    for i in range(1,n + 1):
        print(dist[i],end = ' ')

if __name__ == '__main__':
    solve()
```

##### 优先队列优化 适用于稀疏图

```python
#求解非负权图上的单源最短路径
import heapq
def dijkstra(n,edges,s):
    #构建邻接表
    e = {}
    for u , v ,w in edges:
        if u not in e:
            e[u] = []
        e[u].append((v,w))
    INF = 0x3F3F3F3F
    dist = [INF] * (n + 1)
    dist[s] = 0
    q = [(0,s)]
    st = [False] * (n + 1)
    while q:
        d,u = heapq.heappop(q)
        if d != dist[u]:continue
        st[u] = True
        if u in e:
            for v , w in e[u]:
                if not st[v] and dist[v] > dist[u] + w:
                    dist[v] = dist[u] + w
                    heapq.heappush(q,(dist[v],v))
    return dist
def solve():
    n , m, s = map(int ,input().split())
    edges = []
    for _ in range(m):
        u,v,w = map(int ,input().split())
        edges.append((u,v,w))
    dist = dijkstra(n,edges,s)
    for i in range(1,n + 1):
        print(dist[i],end =' ')
if __name__ == '__main__':
    solve()
```

