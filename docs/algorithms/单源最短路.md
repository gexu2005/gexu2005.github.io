### Bellman-Ford

> Bellmanâ€“Ford ç®—æ³•æ‰€åšçš„ï¼Œå°±æ˜¯ä¸æ–­å°è¯•å¯¹å›¾ä¸Šæ¯ä¸€æ¡è¾¹è¿›è¡Œæ¾å¼›ã€‚æˆ‘ä»¬æ¯è¿›è¡Œä¸€è½®å¾ªç¯ï¼Œå°±å¯¹å›¾ä¸Šæ‰€æœ‰çš„è¾¹éƒ½å°è¯•è¿›è¡Œä¸€æ¬¡æ¾å¼›æ“ä½œï¼Œå½“ä¸€æ¬¡å¾ªç¯ä¸­æ²¡æœ‰æˆåŠŸçš„æ¾å¼›æ“ä½œæ—¶ï¼Œç®—æ³•åœæ­¢ã€‚

> å¦‚æœç¬¬ ğ‘›![n](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7) è½®å¾ªç¯æ—¶ä»ç„¶å­˜åœ¨èƒ½æ¾å¼›çš„è¾¹ï¼Œè¯´æ˜ä» ğ‘†![S](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7) ç‚¹å‡ºå‘ï¼Œèƒ½å¤ŸæŠµè¾¾ä¸€ä¸ªè´Ÿç¯ã€‚(å¸¸ç”¨äºåˆ¤æ–­ä¸€ä¸ªå›¾ä¸­æ˜¯å¦å­˜åœ¨è´Ÿç¯)

> éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œä»¥ ğ‘†![S](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7) ç‚¹ä¸ºæºç‚¹è·‘ Bellmanâ€“Ford ç®—æ³•æ—¶ï¼Œå¦‚æœæ²¡æœ‰ç»™å‡ºå­˜åœ¨è´Ÿç¯çš„ç»“æœï¼Œåªèƒ½è¯´æ˜ä» ğ‘†![S](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7) ç‚¹å‡ºå‘ä¸èƒ½æŠµè¾¾ä¸€ä¸ªè´Ÿç¯ï¼Œè€Œä¸èƒ½è¯´æ˜å›¾ä¸Šä¸å­˜åœ¨è´Ÿç¯ã€‚
>
> å› æ­¤å¦‚æœéœ€è¦åˆ¤æ–­æ•´ä¸ªå›¾ä¸Šæ˜¯å¦å­˜åœ¨è´Ÿç¯ï¼Œæœ€ä¸¥è°¨çš„åšæ³•æ˜¯å»ºç«‹ä¸€ä¸ªè¶…çº§æºç‚¹ï¼Œå‘å›¾ä¸Šæ¯ä¸ªèŠ‚ç‚¹è¿ä¸€æ¡æƒå€¼ä¸º 0 çš„è¾¹ï¼Œç„¶åä»¥è¶…çº§æºç‚¹ä¸ºèµ·ç‚¹æ‰§è¡Œ Bellmanâ€“Ford ç®—æ³•ã€‚

```python
#ç”¨äºæš´åŠ›æ±‚è§£å•æºæœ€çŸ­è·¯å¾„
#åŒæ—¶å¯ä»¥åˆ¤æ–­ä¸€å¼ å›¾ä¸Šæ˜¯å¦å­˜åœ¨è´Ÿç¯ï¼Œå½“æœ€åä¸€è½®æ¾å¼›æ—¶ï¼Œä»æœ‰èŠ‚ç‚¹çš„æœ€çŸ­è·¯è¢«æ›´æ–°ï¼Œè¯´æ˜å­˜åœ¨è´Ÿç¯
#è¯¥ç®—æ³•å¯ä»¥æ±‚å‡ºæœ‰è´Ÿæƒçš„å›¾çš„æœ€çŸ­è·¯
#æ—¶é—´å¤æ‚åº¦Oï¼ˆnmï¼‰
import sys
class Edge:
    def __init__(self,u = 0,v = 0,e = 0):
        self.v = v
        self.u = u
        self.e = e
INF = 0x3F3F3F3F
edge = []
def solve():
    n ,m, s = map(int ,input().split())
    for _ in range(m):
        u ,v ,e = map(int ,input().split())
        edge.append(Edge(u,v,e))
    dis = [INF] * (n + 1)
    dis[s] = 0
    def bellman_ford(n,s):
        flag = False
        for i in range(n):
            flag = False
            for i in edge:
                u ,v ,e = i.u , i.v , i.e
                if dis[u] == INF:continue
                if dis[v] > dis[u] + e:
                    dis[v] = dis[u] + e
                    flag = True
            if not flag:#è¡¨ç¤ºå½“å‰æ²¡æœ‰æ–°çš„èŠ‚ç‚¹çš„æœ€çŸ­è·¯å¾„è¢«æ›´æ–°
                break
        return flag
    if not bellman_ford(n, s):  # è¯´æ˜ä¸å­˜åœ¨è´Ÿç¯
        for i in range(1, n + 1):
            print(dis[i], end=' ')
if __name__ == '__main__':
    solve()
```

> SPFA :å¯¹äºbellman_fordç®—æ³•è¿›è¡Œä¼˜åŒ–ï¼Œæ¯ä¸€æ¬¡æ¾å¼›åªå¯¹ä¸Šä¸€æ¬¡æ¾å¼›ä¸­è¢«æ›´æ–°çš„èŠ‚ç‚¹ä¸ºå‡ºå‘ç‚¹çš„è¾¹è¿›è¡Œæ¾å¼›ï¼Œå‡å°‘ä¸å¿…è¦çš„æ¾å¼›

```python
from collections import deque
class Edge:
    def __init__(self, v=0, w=0):
        self.v = v
        self.w = w
e = [[Edge() for i in range(MAXN)] for j in range(MAXN)]
INF = 0x3F3F3F3F
def spfa(n, s):
    dis = [INF] * (n + 1)
    cnt = [0] * (n + 1)
    vis = [False] * (n + 1)
    q = deque()

    dis[s] = 0
    vis[s] = True
    q.append(s)
    while q:
        u = q.popleft()
        vis[u] = False
        for ed in e[u]:
            v, w = ed.v, ed.w
            if dis[v] > dis[u] + w:
                dis[v] = dis[u] + w
                cnt[v] = cnt[u] + 1  # è®°å½•æœ€çŸ­è·¯ç»è¿‡çš„è¾¹æ•°
                if cnt[v] >= n:
                    return False
                # åœ¨ä¸ç»è¿‡è´Ÿç¯çš„æƒ…å†µä¸‹ï¼Œæœ€çŸ­è·¯è‡³å¤šç»è¿‡ n - 1 æ¡è¾¹
                # å› æ­¤å¦‚æœç»è¿‡äº†å¤šäº n æ¡è¾¹ï¼Œä¸€å®šè¯´æ˜ç»è¿‡äº†è´Ÿç¯
                if not vis[v]:
                    q.append(v)
                    vis[v] = True

```

### Dijkstra

> 1. å°†ç»“ç‚¹åˆ†æˆä¸¤ä¸ªé›†åˆï¼šå·²ç¡®å®šæœ€çŸ­è·¯é•¿åº¦çš„ç‚¹é›†ï¼ˆè®°ä¸º ğ‘†![S](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7) é›†åˆï¼‰çš„å’Œæœªç¡®å®šæœ€çŸ­è·¯é•¿åº¦çš„ç‚¹é›†ï¼ˆè®°ä¸º ğ‘‡![T](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7) é›†åˆï¼‰ã€‚ä¸€å¼€å§‹æ‰€æœ‰çš„ç‚¹éƒ½å±äº ğ‘‡![T](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7) é›†åˆã€‚
> 2. åˆå§‹åŒ– ğ‘‘ğ‘–ğ‘ (ğ‘ ) =0![dis(s)=0](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7)ï¼Œå…¶ä»–ç‚¹çš„ ğ‘‘ğ‘–ğ‘ ![dis](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7) å‡ä¸º +âˆ![+\infty](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7)ã€‚
> 3. é‡å¤ä»¥ä¸‹æ“ä½œ
>    1. ä» ğ‘‡![T](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7) é›†åˆä¸­ï¼Œé€‰å–ä¸€ä¸ªæœ€çŸ­è·¯é•¿åº¦æœ€å°çš„ç»“ç‚¹ï¼Œç§»åˆ° ğ‘†![S](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7) é›†åˆä¸­ã€‚
>    2. å¯¹é‚£äº›åˆšåˆšè¢«åŠ å…¥ ğ‘†![S](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7) é›†åˆçš„ç»“ç‚¹çš„æ‰€æœ‰å‡ºè¾¹æ‰§è¡Œæ¾å¼›æ“ä½œã€‚

##### æœ´ç´ å®ç° é€‚ç”¨äºç¨ å¯†å›¾

```python
import sys
class Edge:
    def __init__(self, v = 0,w = 0):
        self.v = v
        self.w = w
def dijkstra(n ,e, s):
    INF = 0x3F3F3F3F
    dist = [INF] * (n + 1)
    st = [False] * (n + 1)
    dist[s] = 0
    for i in range(1,n + 1):
        u = 0
        mind = INF
        for j in range(1 , n + 1):
            if not st[j] and dist[j] < mind:
                u = j
                mind = dist[j]
        st[u] = True
        for ed in e[u]:
            v , w = ed.v , ed.w
            if dist[v] > dist[u] + w:
                dist[v] = dist[u] + w
    return dist
def solve():
    n , m , s = map(int ,input().split())
    e = [[] for _ in range(n + 1)]
    for _ in range(m):
        u , v , w = map(int ,input().split())
        e[u].append(Edge(v,w))
    dist = dijkstra(n,e,s)
    for i in range(1,n + 1):
        print(dist[i],end = ' ')

if __name__ == '__main__':
    solve()
```

##### ä¼˜å…ˆé˜Ÿåˆ—ä¼˜åŒ– é€‚ç”¨äºç¨€ç–å›¾

```python
#æ±‚è§£éè´Ÿæƒå›¾ä¸Šçš„å•æºæœ€çŸ­è·¯å¾„
import heapq
def dijkstra(n,edges,s):
    #æ„å»ºé‚»æ¥è¡¨
    e = {}
    for u , v ,w in edges:
        if u not in e:
            e[u] = []
        e[u].append((v,w))
    INF = 0x3F3F3F3F
    dist = [INF] * (n + 1)
    dist[s] = 0
    q = [(0,s)]
    st = [False] * (n + 1)
    while q:
        d,u = heapq.heappop(q)
        if d != dist[u]:continue
        st[u] = True
        if u in e:
            for v , w in e[u]:
                if not st[v] and dist[v] > dist[u] + w:
                    dist[v] = dist[u] + w
                    heapq.heappush(q,(dist[v],v))
    return dist
def solve():
    n , m, s = map(int ,input().split())
    edges = []
    for _ in range(m):
        u,v,w = map(int ,input().split())
        edges.append((u,v,w))
    dist = dijkstra(n,edges,s)
    for i in range(1,n + 1):
        print(dist[i],end =' ')
if __name__ == '__main__':
    solve()
```

