### 拓扑排序

> 拓扑排序步骤：
>
> 1. 从图中选择一个入度为0的点
> 2. 输出该顶点，从图中删除此顶点及其所有的出边。

```python
#模版：https://www.luogu.com.cn/problem/B3644
import sys
import queue
def solve():
    #建图 deg存储每个节点的入度
    n = int(input())
    e = [[] for _ in range (110)]
    deg = [0] * 110
    for i in range(1,n + 1):
        a = list(map(int ,input().split()))
        for _ in a:
            if _ != 0:
                e[i].append(_)
                deg[_]+=1
    q = queue.Queue()
    for i in range(1,n + 1):
        if deg[i] == 0:q.put(i)
    while not q.empty():
        t = q.get()#q.get()相当于获取队头元素并弹出
        print(t ,end = ' ')
        for i in e[t]:
            deg[i]-=1
            if deg[i] == 0:
                q.put(i)
if __name__ == '__main__':
    solve()
```

```python
#例题：https://www.luogu.com.cn/problem/P1347
import queue
def topological_sort_check(n, e, deg_in, st):
    deg = deg_in[:]
    q = queue.Queue()
    dist = []
    # 统计图中实际存在的节点数
    nodes_present = 0
    for i in range(1, 27):
        if st[i]:
            nodes_present += 1
            if deg[i] == 0:
                q.put(i)
    # 检查唯一性：初始入度为0的节点多于1个，则不唯一
    is_unique = q.qsize() <= 1
    while not q.empty():
        # 检查唯一性：如果队列中节点多于1个，则不唯一
        if q.qsize() > 1:
            is_unique = False
        u = q.get()
        dist.append(u)
        for v in e[u]:
            deg[v] -= 1
            if deg[v] == 0:
                q.put(v)
    # 1. 不一致性（存在环）：已排序节点数小于图中的总节点数
    if len(dist) < nodes_present:
        return "INCONSISTENCY", None

    # 2. 确定排序：满足三个条件 (节点数达到N, 排序完成, 排序唯一)
    if nodes_present == n and len(dist) == n and is_unique:
        sorted_sequence = "".join([chr(i + ord('A') - 1) for i in dist])
        return "DETERMINED", sorted_sequence
    # 3. 尚未确定
    return "UNDETERMINED", None
def solve():
    n, m = map(int, input().split())
    st = [False] * 27  # 节点是否出现
    deg = [0] * 27  # 原始入度数组
    e = [[] for i in range(27)]  # 邻接表

    # flag用于在找到结果后，跳过后续处理
    flag = False

    for _ in range(m):
        if flag:
            # 找到结果后，只读取输入，不再进行检查
            input()
            continue

        s = input()
        a = ord(s[0]) - ord('A') + 1
        b = ord(s[2]) - ord('A') + 1

        # 跟踪已出现的节点
        st[a] = True
        st[b] = True

        # 添加边和更新原始入度
        if s[1] == '>':  # B < A (B -> A)
            deg[a] += 1
            e[b].append(a)
        else:  # A < B (A -> B)
            deg[b] += 1
            e[a].append(b)

        # 检查当前图的状态
        status, sequence = topological_sort_check(n, e, deg, st)

        if status == "DETERMINED":
            print(f"Sorted sequence determined after {_ + 1} relations: {sequence}.")  # 注意题目要求末尾有'.'
            flag = True
        elif status == "INCONSISTENCY":
            print(f"Inconsistency found after {_ + 1} relations.")
            flag = True
    if not flag:
        print("Sorted sequence cannot be determined.")
if __name__ == '__main__':
    solve()
```

